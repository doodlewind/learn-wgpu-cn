(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{549:function(t,e,n){"use strict";n.r(e);var a=n(23),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"memory-layout-in-wgsl"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#memory-layout-in-wgsl"}},[t._v("#")]),t._v(" Memory Layout in WGSL")]),t._v(" "),n("div",{staticClass:"warn"},[n("p",[t._v("This page is currently being reworked. I want to understand the topics a bit better, but\nas 0.12 is out I want to release what I have for now.")])]),t._v(" "),n("h2",{attrs:{id:"alignment-of-vertex-and-index-buffers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#alignment-of-vertex-and-index-buffers"}},[t._v("#")]),t._v(" Alignment of vertex and index buffers")]),t._v(" "),n("p",[t._v("Vertex buffers require defining a "),n("code",[t._v("VertexBufferLayout")]),t._v(", so the memory alignment is whatever\nyou tell WebGPU it should be. This can be really convenient for keeping down memory usage\non the GPU.")]),t._v(" "),n("p",[t._v("The Index Buffer use the alignment of whatever primitive type you specify via the "),n("code",[t._v("IndexFormat")]),t._v("\nyou pass into "),n("code",[t._v("RenderEncoder::set_index_buffer()")]),t._v(".")]),t._v(" "),n("h2",{attrs:{id:"alignment-of-uniform-and-storage-buffers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#alignment-of-uniform-and-storage-buffers"}},[t._v("#")]),t._v(" Alignment of Uniform and Storage buffers")]),t._v(" "),n("p",[t._v("GPUs are designed to process thousands of pixels in parallel. In order to achieve this,\nsome sacrifices had to be made. Graphics hardware likes to have all the bytes you intend\non processing aligned by powers of 2. The exact specifics of why this is are beyond\nmy level of knowledge, but it's important to know so that you can trouble shoot why your\nshaders aren't working.")]),t._v(" "),n("p",[t._v("Let's take a look at the following table:")]),t._v(" "),n("hr"),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("Type")]),t._v(" "),n("th",[t._v("Alignment in Bytes")]),t._v(" "),n("th",[t._v("Size in Bytes")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("scalar (i32, u32, f32)")]),t._v(" "),n("td",[t._v("4")]),t._v(" "),n("td",[t._v("4")])]),t._v(" "),n("tr",[n("td",[t._v("vec2<T>")]),t._v(" "),n("td",[t._v("8")]),t._v(" "),n("td",[t._v("8")])]),t._v(" "),n("tr",[n("td",[t._v("vec3<T>")]),t._v(" "),n("td",[n("strong",[t._v("16")])]),t._v(" "),n("td",[t._v("12")])]),t._v(" "),n("tr",[n("td",[t._v("vec4<T>")]),t._v(" "),n("td",[t._v("16")]),t._v(" "),n("td",[t._v("16")])])])]),t._v(" "),n("p",[t._v("You can see for "),n("code",[t._v("vec3")]),t._v(" the alignment is the next power of 2 from the size, 16. This can\ncatch beginners (and even veterans) off guard as it's not the most intuitive. This becomes especially\nimportant when we start laying out structs. Take the light struct from the "),n("RouterLink",{attrs:{to:"/intermediate/tutorial10-lighting/#seeing-the-light"}},[t._v("lighting tutorial")]),t._v(":")],1),t._v(" "),n("p",[t._v("You can see the full table of the alignments in section "),n("a",{attrs:{href:"https://www.w3.org/TR/WGSL/#alignment-and-size",target:"_blank",rel:"noopener noreferrer"}},[t._v("4.3.7.1 of the WGSL spec"),n("OutboundLink")],1)]),t._v(" "),n("div",{staticClass:"language-wgsl extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("struct Light {\n    position: vec3<f32>;\n    color: vec3<f32>;\n};\n")])])]),n("p",[t._v("So what's the alignment of this scruct? Your first guess would be that it's the sum of\nthe alignments of the individual fields. That might make sense if we were in Rust-land,\nbut in shader-land, it's a little more involved. The alignment for a given struct is given\nby the following equation:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// S is the struct in question\n// M is a member of the struct\nAlignOf(S) = max(AlignOfMember(S, M1), ... , AlignOfMember(S, Mn))\n")])])]),n("p",[t._v("Basically the alignment of the struct is the maximum of the alignments of the members of\nthe struct. This means that:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("AlignOf(Light) \n    = max(AlignOfMember(Light, position), AlignOfMember(Light, color))\n    = max(16, 16)\n    = 16\n")])])]),n("p",[t._v("This is why the "),n("code",[t._v("LightUniform")]),t._v(" has those padding fields. WGPU won't accept it if the data\nis not aligned correctly.")]),t._v(" "),n("h2",{attrs:{id:"how-to-deal-with-alignment-issues"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#how-to-deal-with-alignment-issues"}},[t._v("#")]),t._v(" How to deal with alignment issues")]),t._v(" "),n("p",[t._v("In general 16, is the max alignment you'll see. In that case you might think that we should\nbe able to do something like the following:")]),t._v(" "),n("div",{staticClass:"language-rust extra-class"},[n("pre",{pre:!0,attrs:{class:"language-rust"}},[n("code",[n("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[repr(C, align(16))]")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("LightUniform")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    position"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f32")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    color"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f32")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("But this won't compile. The "),n("a",{attrs:{href:"https://docs.rs/bytemuck/",target:"_blank",rel:"noopener noreferrer"}},[t._v("bytemuck crate"),n("OutboundLink")],1),t._v(" doesn't work with\nstructs with implicit padding bytes. Rust can't guarantee that the memory between the fields\nhas been initialized properly. This gave be an error when I tried it:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --\x3e code/intermediate/tutorial10-lighting/src/main.rs:246:8\n    |\n246 | struct LightUniform {\n    |        ^^^^^^^^^^^^\n    |\n    = note: source type: `LightUniform` (256 bits)\n    = note: target type: `_::{closure#0}::TypeWithoutPadding` (192 bits)\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);